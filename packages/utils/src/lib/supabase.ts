import { createClient } from "@supabase/supabase-js";
import { Database } from "../../types/database.types";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables");
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// =====================================================
// TYPE DEFINITIONS (Using Database Types)
// =====================================================

// Use autogenerated types from Database
export type Category = Database["public"]["Tables"]["categories"]["Row"];
export type Product = Database["public"]["Tables"]["products"]["Row"];
export type ProductVariant =
  Database["public"]["Tables"]["product_variants"]["Row"];
export type ProductOption =
  Database["public"]["Tables"]["product_options"]["Row"];
export type ProductOptionValue =
  Database["public"]["Tables"]["product_option_values"]["Row"];
export type Order = Database["public"]["Tables"]["orders"]["Row"];
export type Review = Database["public"]["Tables"]["reviews"]["Row"];

// Function return types
export type CartItem =
  Database["public"]["Functions"]["get_cart_items"]["Returns"][number];
export type ProductWithDetails =
  Database["public"]["Functions"]["get_product_by_id"]["Returns"][number];
export type ProductOptionsResult =
  Database["public"]["Functions"]["get_product_options"]["Returns"][number];
export type VariantByOptions =
  Database["public"]["Functions"]["find_variant_by_options"]["Returns"][number];

// Custom interfaces for enhanced functionality
export interface CartSummary {
  total_amount: number;
  item_count: number;
  shipping: number;
  tax: number;
  discount: number;
}

export interface ProductFilters {
  categorySlug?: string;
  searchTerm?: string;
  minPrice?: number;
  maxPrice?: number;
  sortBy?: "name" | "price_asc" | "price_desc" | "rating" | "newest";
  limit?: number;
  offset?: number;
}

export interface VariantSelection {
  [optionName: string]: string; // option name -> option value id
}

export interface CustomerInfo {
  email: string;
  name?: string;
  phone?: string;
  shippingAddress?: Record<string, any>;
  billingAddress?: Record<string, any>;
}

// Helper interfaces for variant data
export interface ProductVariantInfo {
  variant_id: string;
  sku: string;
  price: number;
  stock_quantity: number;
  is_available: boolean;
  image_url?: string | null;
  images_gallery?: string[] | null;
  options: Array<{
    option_name: string;
    option_display_name: string;
    option_type: string;
    value: string;
    display_name: string;
    hex_color?: string | null;
    image_url?: string | null;
  }>;
}

export interface ProductOptionInfo {
  option_id: string;
  option_name: string;
  option_display_name: string;
  option_type: "select" | "swatch" | "button";
  option_position: number;
  is_required: boolean;
  option_values: Array<{
    id: string;
    value: string;
    display_name: string;
    hex_color?: string | null;
    image_url?: string | null;
    position: number;
  }>;
}

// =====================================================
// SESSION MANAGEMENT
// =====================================================

class SessionManager {
  private sessionId: string;

  constructor() {
    this.sessionId = this.getOrCreateSessionId();
  }

  private getOrCreateSessionId(): string {
    let sessionId = localStorage.getItem("cart_session_id");
    if (!sessionId) {
      sessionId = `session_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      localStorage.setItem("cart_session_id", sessionId);
    }
    return sessionId;
  }

  getSessionId(): string {
    return this.sessionId;
  }

  clearSession(): void {
    localStorage.removeItem("cart_session_id");
    this.sessionId = this.getOrCreateSessionId();
  }
}

const sessionManager = new SessionManager();

// =====================================================
// ENHANCED API CLIENT
// =====================================================

export class SupabaseAPI {
  // =====================================================
  // CATEGORIES
  // =====================================================

  static async getCategories(): Promise<Category[]> {
    const { data, error } = await supabase
      .from("categories")
      .select("*")
      .eq("is_active", true)
      .order("name");

    if (error) throw new Error(`Failed to fetch categories: ${error.message}`);
    return data || [];
  }

  // =====================================================
  // PRODUCTS (Enhanced with Integrated Variant Support)
  // =====================================================

  static async getProducts(params: ProductFilters = {}) {
    const {
      categorySlug,
      searchTerm,
      minPrice,
      maxPrice,
      sortBy = "name",
      limit = 50,
      offset = 0,
    } = params;

    const { data, error } = await supabase.rpc("get_products", {
      category_slug_param: categorySlug,
      search_term: searchTerm,
      min_price: minPrice,
      max_price: maxPrice,
      sort_by: sortBy,
      limit_count: limit,
      offset_count: offset,
    });

    if (error) throw new Error(`Failed to fetch products: ${error.message}`);
    return data || [];
  }

  /**
   * Get product by ID with integrated variant and option data
   * This now replaces both getProductById and getProductWithVariants
   */
  static async getProductById(
    productId: string
  ): Promise<ProductWithDetails | null> {
    const { data, error } = await supabase.rpc("get_product_by_id", {
      product_id_param: productId,
    });

    if (error) throw new Error(`Failed to fetch product: ${error.message}`);
    return data?.[0] || null;
  }

  static async getProductsByCategory(categorySlug: string) {
    return this.getProducts({ categorySlug });
  }

  static async searchProducts(searchTerm: string) {
    return this.getProducts({ searchTerm });
  }

  // =====================================================
  // VARIANT-SPECIFIC FUNCTIONS
  // =====================================================

  /**
   * Get available options for a product (e.g., Color, Size)
   * Use this when you need just the options without the full product data
   */
  static async getProductOptions(
    productId: string
  ): Promise<ProductOptionsResult[]> {
    const { data, error } = await supabase.rpc("get_product_options", {
      product_id_param: productId,
    });

    if (error)
      throw new Error(`Failed to fetch product options: ${error.message}`);
    return data || [];
  }

  /**
   * Find a specific variant by selected option combinations
   */
  static async findVariantByOptions(
    productId: string,
    optionValueIds: string[]
  ): Promise<VariantByOptions | null> {
    const { data, error } = await supabase.rpc("find_variant_by_options", {
      product_id_param: productId,
      option_value_ids: optionValueIds,
    });

    if (error) throw new Error(`Failed to find variant: ${error.message}`);
    return data?.[0] || null;
  }

  /**
   * Helper function to get variant by selection object
   */
  static async findVariantBySelection(
    productId: string,
    selection: VariantSelection
  ): Promise<VariantByOptions | null> {
    const optionValueIds = Object.values(selection);
    return this.findVariantByOptions(productId, optionValueIds);
  }

  // =====================================================
  // ENHANCED CART MANAGEMENT (with Variant Support)
  // =====================================================

  /**
   * Add product to cart (with optional variant support)
   * Backward compatible - variantId is optional
   */
  static async addToCart(
    productId: string,
    quantity: number = 1,
    variantId?: string
  ): Promise<string | null> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("upsert_cart_item", {
      session_id_param: sessionId,
      product_id_param: productId,
      quantity_param: quantity,
      variant_id_param: variantId,
    });

    if (error) throw new Error(`Failed to add to cart: ${error.message}`);
    return data;
  }

  /**
   * Update cart item quantity (with variant support)
   */
  static async updateCartItemQuantity(
    productId: string,
    quantity: number,
    variantId?: string
  ): Promise<string | null> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("upsert_cart_item", {
      session_id_param: sessionId,
      product_id_param: productId,
      quantity_param: quantity,
      variant_id_param: variantId,
    });

    if (error) throw new Error(`Failed to update cart item: ${error.message}`);
    return data;
  }

  /**
   * Remove from cart (with variant support)
   */
  static async removeFromCart(
    productId: string,
    variantId?: string
  ): Promise<boolean> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("remove_cart_item", {
      session_id_param: sessionId,
      product_id_param: productId,
      variant_id_param: variantId,
    });

    if (error) throw new Error(`Failed to remove from cart: ${error.message}`);
    return data || false;
  }

  /**
   * Get cart items (now includes variant information)
   */
  static async getCartItems(): Promise<CartItem[]> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("get_cart_items", {
      session_id_param: sessionId,
    });

    if (error) throw new Error(`Failed to fetch cart items: ${error.message}`);
    return data || [];
  }

  static async getCartSummary(): Promise<CartSummary> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("get_cart_summary", {
      session_id_param: sessionId,
    });

    if (error)
      throw new Error(`Failed to fetch cart summary: ${error.message}`);
    return (
      data?.[0] || {
        total_amount: 0,
        item_count: 0,
        shipping: 0,
        tax: 0,
        discount: 0,
      }
    );
  }

  static async clearCart(): Promise<number> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("clear_cart", {
      session_id_param: sessionId,
    });

    if (error) throw new Error(`Failed to clear cart: ${error.message}`);
    return data || 0;
  }

  /**
   * Get cart item quantity for a specific product (with variant support)
   */
  static async getCartItemQuantity(
    productId: string,
    variantId?: string
  ): Promise<number> {
    const cartItems = await this.getCartItems();
    const item = cartItems.find(
      (item) =>
        item.product_id === productId &&
        (variantId ? item.variant_id === variantId : !item.variant_id)
    );
    return item?.quantity || 0;
  }

  // =====================================================
  // ORDERS (Enhanced with Variant Support)
  // =====================================================

  static async createOrderFromCart(orderData: {
    stripeSessionId: string;
    customerEmail: string;
    customerName: string;
    customerPhone?: string;
    shippingAddress?: Record<string, any>;
    billingAddress?: Record<string, any>;
  }): Promise<string> {
    const sessionId = sessionManager.getSessionId();

    const { data, error } = await supabase.rpc("create_order_from_cart", {
      session_id_param: sessionId,
      stripe_session_id_param: orderData.stripeSessionId,
      customer_email_param: orderData.customerEmail,
      customer_name_param: orderData.customerName,
      customer_phone_param: orderData.customerPhone,
      shipping_address_param: orderData.shippingAddress || null,
      billing_address_param: orderData.billingAddress || null,
    });

    if (error) throw new Error(`Failed to create order: ${error.message}`);
    if (!data) throw new Error("Order creation failed");

    // Clear session after successful order
    sessionManager.clearSession();

    return data;
  }

  static async getOrderByStripeSession(
    stripeSessionId: string
  ): Promise<Order | null> {
    const { data, error } = await supabase.rpc("get_order_by_stripe_session", {
      stripe_session_id_param: stripeSessionId,
    });

    if (error) throw new Error(`Failed to fetch order: ${error.message}`);
    return (data?.[0] as Order) || null;
  }

  // =====================================================
  // REVIEWS
  // =====================================================

  static async getProductReviews(productId: string): Promise<Review[]> {
    const { data, error } = await supabase
      .from("reviews")
      .select("*")
      .eq("product_id", productId)
      .eq("is_approved", true)
      .order("created_at", { ascending: false });

    if (error) throw new Error(`Failed to fetch reviews: ${error.message}`);
    return data || [];
  }

  static async addReview(reviewData: {
    productId: string;
    rating: number;
    title?: string;
    comment?: string;
    reviewerName?: string;
    reviewerEmail?: string;
  }): Promise<string> {
    const { data, error } = await supabase
      .from("reviews")
      .insert({
        product_id: reviewData.productId,
        rating: reviewData.rating,
        title: reviewData.title || null,
        comment: reviewData.comment || null,
        reviewer_name: reviewData.reviewerName || null,
        reviewer_email: reviewData.reviewerEmail || null,
      })
      .select("id")
      .single();

    if (error) throw new Error(`Failed to add review: ${error.message}`);
    return data.id;
  }

  // =====================================================
  // CHECKOUT & EXTERNAL SERVICES
  // =====================================================

  static async createCheckoutSession({
    customerInfo,
  }: {
    customerInfo: CustomerInfo;
  }): Promise<{ url: string }> {
    const sessionId = sessionManager.getSessionId();
    const response = await fetch(
      `${supabaseUrl}/functions/v1/create-stripe-checkout`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${supabaseAnonKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          sessionId,
          customerInfo,
          successUrl: `${window.location.origin}/success?session_id={CHECKOUT_SESSION_ID}`,
          cancelUrl: `${window.location.origin}/checkout`,
        }),
      }
    );
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        `Failed to create checkout session: ${errorData.message}`
      );
    }
    return response.json();
  }

  static async submitContactForm(
    formData: Record<string, string>
  ): Promise<void> {
    const response = await fetch(`${supabaseUrl}/functions/v1/resend`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${supabaseAnonKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        templateId: "contact-form",
        variables: formData,
      }),
    });
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Failed to submit contact form: ${errorData.message}`);
    }
    const result = await response.json();
    if (!result.sent) {
      throw new Error("Failed to send contact form email");
    }
  }

  // =====================================================
  // UTILITY FUNCTIONS
  // =====================================================

  static async cleanupExpiredCartItems(): Promise<number> {
    const { data, error } = await supabase.rpc("cleanup_expired_cart_items");

    if (error) throw new Error(`Failed to cleanup cart: ${error.message}`);
    return data || 0;
  }

  static async healthCheck(): Promise<boolean> {
    try {
      const { error } = await supabase.from("categories").select("id").limit(1);
      return !error;
    } catch {
      return false;
    }
  }

  // =====================================================
  // HELPER FUNCTIONS FOR VARIANTS
  // =====================================================

  /**
   * Helper to check if a product has variants
   */
  static hasVariants(product: ProductWithDetails): boolean {
    return product.has_variants || false;
  }

  /**
   * Helper to get all variants for a product (from the integrated response)
   */
  static getProductVariants(product: ProductWithDetails): ProductVariantInfo[] {
    if (!product.variants || !Array.isArray(product.variants)) {
      return [];
    }
    return product.variants as unknown as ProductVariantInfo[];
  }

  /**
   * Helper to get all options for a product (from the integrated response)
   */
  static getProductOptionsFromProduct(
    product: ProductWithDetails
  ): ProductOptionInfo[] {
    if (!product.options || !Array.isArray(product.options)) {
      return [];
    }
    return product.options as unknown as ProductOptionInfo[];
  }

  /**
   * Helper to format variant options for display
   */
  static formatVariantOptions(cartItem: CartItem): string {
    if (!cartItem.variant_options || !Array.isArray(cartItem.variant_options)) {
      return "";
    }

    return cartItem.variant_options
      .map((option: any) => `${option.option_name}: ${option.value}`)
      .join(", ");
  }

  /**
   * Helper to get variant price (base price + adjustment)
   */
  static getVariantPrice(basePrice: number, variant?: ProductVariant): number {
    if (!variant) return basePrice;
    return basePrice + (variant.price_adjustment || 0);
  }

  /**
   * Helper to find a specific variant from the product data
   */
  static findVariantInProduct(
    product: ProductWithDetails,
    variantId: string
  ): ProductVariantInfo | null {
    const variants = this.getProductVariants(product);
    return variants.find((v) => v.variant_id === variantId) || null;
  }

  /**
   * Helper to get the lowest priced variant for a product
   */
  static getLowestPricedVariant(
    product: ProductWithDetails
  ): ProductVariantInfo | null {
    const variants = this.getProductVariants(product);
    if (variants.length === 0) return null;

    return variants.reduce((lowest, current) =>
      current.price < lowest.price ? current : lowest
    );
  }

  /**
   * Helper to get available stock for a product (considering variants)
   */
  static getAvailableStock(
    product: ProductWithDetails,
    variantId?: string
  ): number {
    if (variantId) {
      const variant = this.findVariantInProduct(product, variantId);
      return variant?.stock_quantity || 0;
    }

    // If no variant specified, return total product stock (auto-managed)
    return product.stock_quantity || 0;
  }

  /**
   * Helper to check if a product/variant is in stock
   */
  static isInStock(product: ProductWithDetails, variantId?: string): boolean {
    return this.getAvailableStock(product, variantId) > 0;
  }

  /**
   * Helper to get option value by ID from product options
   */
  static getOptionValueById(
    product: ProductWithDetails,
    optionValueId: string
  ): { option: ProductOptionInfo; value: any } | null {
    const options = this.getProductOptionsFromProduct(product);

    for (const option of options) {
      const value = option.option_values.find((v) => v.id === optionValueId);
      if (value) {
        return { option, value };
      }
    }

    return null;
  }
}

// =====================================================
// CONVENIENCE EXPORTS
// =====================================================

// Export convenience functions for direct use (backward compatible)
export const {
  getCategories,
  getProducts,
  getProductById,
  getProductsByCategory,
  searchProducts,
  addToCart,
  updateCartItemQuantity,
  removeFromCart,
  getCartItems,
  getCartSummary,
  getCartItemQuantity,
  clearCart,
  createOrderFromCart,
  getOrderByStripeSession,
  getProductReviews,
  addReview,
  cleanupExpiredCartItems,
  healthCheck,
  // Variant functions
  getProductOptions,
  findVariantByOptions,
  findVariantBySelection,
  // Helper functions
  hasVariants,
  getProductVariants,
  getProductOptionsFromProduct,
  formatVariantOptions,
  getVariantPrice,
  findVariantInProduct,
  getLowestPricedVariant,
  getAvailableStock,
  isInStock,
  getOptionValueById,
} = SupabaseAPI;

// Default export
export default SupabaseAPI;
